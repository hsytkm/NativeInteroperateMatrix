// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MatrixContainerTemplate.tt. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
namespace Nima;

public /*sealed*/ class ByteMatrixContainer : MatrixContainerBase
{
    public ByteMatrixContainer(int rows, int columns, bool initialize = true)
        : base(rows, columns, Unsafe.SizeOf<Byte>(), initialize)
    { }

    public ByteMatrixContainer(int rows, int columns, IEnumerable<Byte> items)
        : this(rows, columns, false)
    {
        int length = rows * columns;
        int row = 0;
        int column = int.MaxValue;
        var span = Span<Byte>.Empty;

#if NET6_0_OR_GREATER
        if (items.TryGetNonEnumeratedCount(out var count))
        {
            if (length < count)
            {
                throw new IndexOutOfRangeException("Items is large.");
            }
            else if (length > count)
            {
                throw new ArgumentException("Items is small.", nameof(items));
            }

            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Byte>(row++);
                }
                span[column++] = item;
            }
        }
        else
#endif
        {
            int written = 0;
            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Byte>(row++);
                }
                span[column++] = item;

                if (++written > length)
                    throw new IndexOutOfRangeException("Items is large.");
            }

            if (!(row == rows && column == columns))
                throw new ArgumentException("Items is small.", nameof(items));
        }
    }

    public ByteMatrixContainer(int rows, int columns, ReadOnlySpan<Byte> items)
        : this(rows, columns, false)
    {
        if (rows * columns != items.Length)
            throw new ArgumentException("Items is different length.", nameof(items));

        int row = 0;
        int column = int.MaxValue;
        var span = Span<Byte>.Empty;

        foreach (var item in items)
        {
            if (column >= columns)
            {
                column = 0;
                span = Matrix.AsRowSpan<Byte>(row++);
            }
            span[column++] = item;
        }
    }
}

public /*sealed*/ class Int16MatrixContainer : MatrixContainerBase
{
    public Int16MatrixContainer(int rows, int columns, bool initialize = true)
        : base(rows, columns, Unsafe.SizeOf<Int16>(), initialize)
    { }

    public Int16MatrixContainer(int rows, int columns, IEnumerable<Int16> items)
        : this(rows, columns, false)
    {
        int length = rows * columns;
        int row = 0;
        int column = int.MaxValue;
        var span = Span<Int16>.Empty;

#if NET6_0_OR_GREATER
        if (items.TryGetNonEnumeratedCount(out var count))
        {
            if (length < count)
            {
                throw new IndexOutOfRangeException("Items is large.");
            }
            else if (length > count)
            {
                throw new ArgumentException("Items is small.", nameof(items));
            }

            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Int16>(row++);
                }
                span[column++] = item;
            }
        }
        else
#endif
        {
            int written = 0;
            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Int16>(row++);
                }
                span[column++] = item;

                if (++written > length)
                    throw new IndexOutOfRangeException("Items is large.");
            }

            if (!(row == rows && column == columns))
                throw new ArgumentException("Items is small.", nameof(items));
        }
    }

    public Int16MatrixContainer(int rows, int columns, ReadOnlySpan<Int16> items)
        : this(rows, columns, false)
    {
        if (rows * columns != items.Length)
            throw new ArgumentException("Items is different length.", nameof(items));

        int row = 0;
        int column = int.MaxValue;
        var span = Span<Int16>.Empty;

        foreach (var item in items)
        {
            if (column >= columns)
            {
                column = 0;
                span = Matrix.AsRowSpan<Int16>(row++);
            }
            span[column++] = item;
        }
    }
}

public /*sealed*/ class Int32MatrixContainer : MatrixContainerBase
{
    public Int32MatrixContainer(int rows, int columns, bool initialize = true)
        : base(rows, columns, Unsafe.SizeOf<Int32>(), initialize)
    { }

    public Int32MatrixContainer(int rows, int columns, IEnumerable<Int32> items)
        : this(rows, columns, false)
    {
        int length = rows * columns;
        int row = 0;
        int column = int.MaxValue;
        var span = Span<Int32>.Empty;

#if NET6_0_OR_GREATER
        if (items.TryGetNonEnumeratedCount(out var count))
        {
            if (length < count)
            {
                throw new IndexOutOfRangeException("Items is large.");
            }
            else if (length > count)
            {
                throw new ArgumentException("Items is small.", nameof(items));
            }

            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Int32>(row++);
                }
                span[column++] = item;
            }
        }
        else
#endif
        {
            int written = 0;
            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Int32>(row++);
                }
                span[column++] = item;

                if (++written > length)
                    throw new IndexOutOfRangeException("Items is large.");
            }

            if (!(row == rows && column == columns))
                throw new ArgumentException("Items is small.", nameof(items));
        }
    }

    public Int32MatrixContainer(int rows, int columns, ReadOnlySpan<Int32> items)
        : this(rows, columns, false)
    {
        if (rows * columns != items.Length)
            throw new ArgumentException("Items is different length.", nameof(items));

        int row = 0;
        int column = int.MaxValue;
        var span = Span<Int32>.Empty;

        foreach (var item in items)
        {
            if (column >= columns)
            {
                column = 0;
                span = Matrix.AsRowSpan<Int32>(row++);
            }
            span[column++] = item;
        }
    }
}

public /*sealed*/ class Int64MatrixContainer : MatrixContainerBase
{
    public Int64MatrixContainer(int rows, int columns, bool initialize = true)
        : base(rows, columns, Unsafe.SizeOf<Int64>(), initialize)
    { }

    public Int64MatrixContainer(int rows, int columns, IEnumerable<Int64> items)
        : this(rows, columns, false)
    {
        int length = rows * columns;
        int row = 0;
        int column = int.MaxValue;
        var span = Span<Int64>.Empty;

#if NET6_0_OR_GREATER
        if (items.TryGetNonEnumeratedCount(out var count))
        {
            if (length < count)
            {
                throw new IndexOutOfRangeException("Items is large.");
            }
            else if (length > count)
            {
                throw new ArgumentException("Items is small.", nameof(items));
            }

            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Int64>(row++);
                }
                span[column++] = item;
            }
        }
        else
#endif
        {
            int written = 0;
            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Int64>(row++);
                }
                span[column++] = item;

                if (++written > length)
                    throw new IndexOutOfRangeException("Items is large.");
            }

            if (!(row == rows && column == columns))
                throw new ArgumentException("Items is small.", nameof(items));
        }
    }

    public Int64MatrixContainer(int rows, int columns, ReadOnlySpan<Int64> items)
        : this(rows, columns, false)
    {
        if (rows * columns != items.Length)
            throw new ArgumentException("Items is different length.", nameof(items));

        int row = 0;
        int column = int.MaxValue;
        var span = Span<Int64>.Empty;

        foreach (var item in items)
        {
            if (column >= columns)
            {
                column = 0;
                span = Matrix.AsRowSpan<Int64>(row++);
            }
            span[column++] = item;
        }
    }
}

public /*sealed*/ class SingleMatrixContainer : MatrixContainerBase
{
    public SingleMatrixContainer(int rows, int columns, bool initialize = true)
        : base(rows, columns, Unsafe.SizeOf<Single>(), initialize)
    { }

    public SingleMatrixContainer(int rows, int columns, IEnumerable<Single> items)
        : this(rows, columns, false)
    {
        int length = rows * columns;
        int row = 0;
        int column = int.MaxValue;
        var span = Span<Single>.Empty;

#if NET6_0_OR_GREATER
        if (items.TryGetNonEnumeratedCount(out var count))
        {
            if (length < count)
            {
                throw new IndexOutOfRangeException("Items is large.");
            }
            else if (length > count)
            {
                throw new ArgumentException("Items is small.", nameof(items));
            }

            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Single>(row++);
                }
                span[column++] = item;
            }
        }
        else
#endif
        {
            int written = 0;
            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Single>(row++);
                }
                span[column++] = item;

                if (++written > length)
                    throw new IndexOutOfRangeException("Items is large.");
            }

            if (!(row == rows && column == columns))
                throw new ArgumentException("Items is small.", nameof(items));
        }
    }

    public SingleMatrixContainer(int rows, int columns, ReadOnlySpan<Single> items)
        : this(rows, columns, false)
    {
        if (rows * columns != items.Length)
            throw new ArgumentException("Items is different length.", nameof(items));

        int row = 0;
        int column = int.MaxValue;
        var span = Span<Single>.Empty;

        foreach (var item in items)
        {
            if (column >= columns)
            {
                column = 0;
                span = Matrix.AsRowSpan<Single>(row++);
            }
            span[column++] = item;
        }
    }
}

public /*sealed*/ class DoubleMatrixContainer : MatrixContainerBase
{
    public DoubleMatrixContainer(int rows, int columns, bool initialize = true)
        : base(rows, columns, Unsafe.SizeOf<Double>(), initialize)
    { }

    public DoubleMatrixContainer(int rows, int columns, IEnumerable<Double> items)
        : this(rows, columns, false)
    {
        int length = rows * columns;
        int row = 0;
        int column = int.MaxValue;
        var span = Span<Double>.Empty;

#if NET6_0_OR_GREATER
        if (items.TryGetNonEnumeratedCount(out var count))
        {
            if (length < count)
            {
                throw new IndexOutOfRangeException("Items is large.");
            }
            else if (length > count)
            {
                throw new ArgumentException("Items is small.", nameof(items));
            }

            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Double>(row++);
                }
                span[column++] = item;
            }
        }
        else
#endif
        {
            int written = 0;
            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    span = Matrix.AsRowSpan<Double>(row++);
                }
                span[column++] = item;

                if (++written > length)
                    throw new IndexOutOfRangeException("Items is large.");
            }

            if (!(row == rows && column == columns))
                throw new ArgumentException("Items is small.", nameof(items));
        }
    }

    public DoubleMatrixContainer(int rows, int columns, ReadOnlySpan<Double> items)
        : this(rows, columns, false)
    {
        if (rows * columns != items.Length)
            throw new ArgumentException("Items is different length.", nameof(items));

        int row = 0;
        int column = int.MaxValue;
        var span = Span<Double>.Empty;

        foreach (var item in items)
        {
            if (column >= columns)
            {
                column = 0;
                span = Matrix.AsRowSpan<Double>(row++);
            }
            span[column++] = item;
        }
    }
}

