<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Matrix.SourceGenerator. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

<# if (!string.IsNullOrEmpty(Namespace)) { #>
namespace <#= Namespace #>
<# } #>
{
    // Do not change the order of the struct because it is the same as C++
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 8 + (4 * 4))]
    partial record struct <#= MatrixClassName #> : IMatrix<<#= ValueItemTypeName #>>
    {
        readonly IntPtr _pointer;
        //readonly int _allocSize;  // = rows * stride;
        readonly int _rows;         // height
        readonly int _columns;      // width
        readonly int _bytesPerItem;
        readonly int _stride;

        public <#= MatrixClassName #>(IntPtr intPtr, int rows, int columns, int bytesPerItem, int stride)
        {
            if (IntPtr.Size != 8)
                throw new NotSupportedException("Must be x64");

            if (bytesPerItem != Unsafe.SizeOf<<#= ValueItemTypeName #>>())
                throw new ArgumentException(nameof(bytesPerItem));

            _pointer = intPtr;
            _rows = rows;
            _columns = columns;
            _bytesPerItem = bytesPerItem;
            _stride = stride;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ThrowInvalidRow(int row)
        {
            if (row < 0 || _rows - 1 < row)
                throw new ArgumentException($"Invalid row={row}");
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ThrowInvalidColumn(int column)
        {
            if (column < 0 || _columns - 1 < column)
                throw new ArgumentException($"Invalid column={column}");
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ThrowInvalidRowColumn(int row, int column)
        {
            ThrowInvalidRow(row);
            ThrowInvalidColumn(column);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        IntPtr GetIntPtr(int row, int column)
        {
            ThrowInvalidRowColumn(row, column);
            return _pointer + (row * _stride) + (column * _bytesPerItem);
        }

        // INativeMemory
        public IntPtr Pointer => _pointer;
        public int AllocatedSize => _columns * _bytesPerItem * _rows;  // don't use stride
        public int BytesPerItem => _bytesPerItem;
        public int BitsPerItem => _bytesPerItem * 8;
        public bool IsValid
        {
            get
            {
                if (_pointer == IntPtr.Zero) return false;
                if (_columns <= 0 || _rows <= 0) return false;
                if (_stride < _columns * _bytesPerItem) return false;
                return true;    //valid
            }
        }

        // IMatrix
        public int Rows => _rows;
        public int Columns => _columns;
        public int Stride => _stride;
        public bool IsContinuous => (_columns * _bytesPerItem) == _stride;

        // IMatrix<T>
        public unsafe ref <#= ValueItemTypeName #> this[int row, int column]
        {
            get
            {
                IntPtr ptr = GetIntPtr(row, column);
                return ref Unsafe.AsRef<<#= ValueItemTypeName #>>(ptr.ToPointer());
            }
        }

        public unsafe Span<<#= ValueItemTypeName #>> AsSpan()
        {
            int size = _rows * _stride;
            return new Span<<#= ValueItemTypeName #>>(_pointer.ToPointer(), size);
        }

        public unsafe Span<<#= ValueItemTypeName #>> AsRowSpan(int row)
        {
            ThrowInvalidRow(row);

            IntPtr ptr = _pointer + (row * _stride);
            return new Span<<#= ValueItemTypeName #>>(ptr.ToPointer(), _columns);
        }

        public override string ToString() => $"Rows={_rows}, Cols={_columns}, Pointer=0x{_pointer:x16}";
    }

    public /*sealed*/ partial class <#= ContainerClassName #> : IMatrixContainer<<#= ValueItemTypeName #>>, IDisposable
    {
        public <#= MatrixClassName #> Matrix { get; }
        public IMatrix<<#= ValueItemTypeName #>> MatrixT => (IMatrix<<#= ValueItemTypeName #>>)Matrix;

        readonly record struct PointerSizePair
        {
            public static readonly PointerSizePair Zero = new(IntPtr.Zero, 0);
            public IntPtr Pointer { get; }
            public int Size { get; }
            public PointerSizePair(IntPtr ptr, int size) => (Pointer, Size) = (ptr, size);
            public void Deconstruct(out IntPtr ptr, out int size) => (ptr, size) = (Pointer, Size);
        }

        PointerSizePair _allocatedMemory;
        
        public <#= ContainerClassName #>(int rows, int columns, bool initialize)
        {
            int bytesPerData = Unsafe.SizeOf<<#= ValueItemTypeName #>>();
            int stride = columns * bytesPerData;
            _allocatedMemory = Alloc(stride * rows);
            (IntPtr ptr, int allocSize) = _allocatedMemory;

            if (initialize)
            {
                UnsafeUtils.FillZero(ptr, allocSize);
            }
            
            Matrix = new <#= MatrixClassName #>(ptr, rows, columns, bytesPerData, stride);
        }

        public <#= ContainerClassName #>(int rows, int columns)
            : this(rows, columns, true)
        { }

        public <#= ContainerClassName #>(int rows, int columns, IEnumerable<<#= ValueItemTypeName #>> items)
            : this(rows, columns, false)
        {
            int length = rows * columns;
            int written = 0;
            int row = 0;
            int column = 0;
            var span = Matrix.AsRowSpan(0);

            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    row++;
                    span = Matrix.AsRowSpan(row);
                }
                span[column++] = item;

                if (++written > length)
                    throw new ArgumentException("items is large.", nameof(items));
            }

            if (!(row == rows - 1 && column == columns))
                throw new ArgumentException("items is small.", nameof(items));
        }
        
        public <#= ContainerClassName #>(int rows, int columns, ReadOnlySpan<<#= ValueItemTypeName #>> items)
            : this(rows, columns, false)
        {
            int length = rows * columns;
            int written = 0;
            int row = 0;
            int column = 0;
            var span = Matrix.AsRowSpan(0);

            foreach (var item in items)
            {
                if (column >= columns)
                {
                    column = 0;
                    row++;
                    span = Matrix.AsRowSpan(row);
                }
                span[column++] = item;

                if (++written > length)
                    throw new ArgumentException("items is large.", nameof(items));
            }

            if (!(row == rows - 1 && column == columns))
                throw new ArgumentException("items is small.", nameof(items));
        }
        
        public <#= ContainerClassName #>(int rows, int columns, ReadOnlySpan<byte> items)
            : this(rows, columns, MemoryMarshal.Cast<byte, <#= ValueItemTypeName #>>(bytes))
        { }

        static PointerSizePair Alloc(int size)
        {
            IntPtr intPtr;
#if NET6_0_OR_GREATER
            unsafe { intPtr = (IntPtr)NativeMemory.Alloc((nuint)size); }
#else
            intPtr = Marshal.AllocCoTaskMem(size);
#endif
            GC.AddMemoryPressure(size);
            return new(intPtr, size);
        }

        static void Free(in PointerSizePair pair)
        {
#if NET6_0_OR_GREATER
            unsafe { NativeMemory.Free((void*)pair.Pointer); }
#else
            Marshal.FreeCoTaskMem(pair.Pointer);
#endif
            GC.RemoveMemoryPressure(pair.Size);
        }
        
        bool _disposedValue;
        public void Dispose(bool disposing)
        {
            if (_disposedValue) return;

            if (disposing)
            {
                // TODO: dispose managed state (managed objects).
            }

            // TODO: free unmanaged resources (unmanaged objects) and override a finalizer below.
            if (_allocatedMemory != PointerSizePair.Zero)
            {
                Free(_allocatedMemory);
                _allocatedMemory = PointerSizePair.Zero;
            }

            _disposedValue = true;
        }

        ~<#= ContainerClassName #>() => Dispose(false);

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}
