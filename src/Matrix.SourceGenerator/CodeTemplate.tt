<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Matrix.SourceGenerator. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

<# if (!string.IsNullOrEmpty(Namespace)) { #>
namespace <#= Namespace #>
<# } #>
{
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 8 + (4 * 4))]
    readonly partial struct <#= ClassName #> : IEquatable<<#= ClassName #>>, IMatrix<<#= ItemTypeName #>>
    {
        private readonly IntPtr _pointer;
        //private readonly int _allocSize;  // = rows * stride;
        private readonly int _rows;         // height
        private readonly int _columns;      // width
        private readonly int _bytesPerItem;
        private readonly int _stride;

        public <#= ClassName #>(int rows, int columns, int bytesPerItem, int stride, IntPtr intPtr)
        {
            if (IntPtr.Size != 8)
                throw new NotSupportedException();

            if (bytesPerItem != sizeof(<#= ItemTypeName #>))
                throw new ArgumentException(nameof(bytesPerItem));

            _rows = rows;
            _columns = columns;
            _bytesPerItem = bytesPerItem;
            _stride = stride;
            _pointer = intPtr;
        }

        // IMatrix<T>
        public IntPtr Pointer => _pointer;
        public int Rows => _rows;
        public int Columns => _columns;
        public int BytesPerItem => _bytesPerItem;
        public int BitsPerItem => _bytesPerItem * 8;
        public int Stride => _stride;
        public int Width => _columns;
        public int Height => _rows;

        // MatrixExtension
        public int AllocatedSize => this.GetAllocatedSize<<#= ClassName #>, <#= ItemTypeName #>>();
        public bool IsContinuous => this.IsContinuous<<#= ClassName #>, <#= ItemTypeName #>>();
        public bool IsValid => this.IsValid<<#= ClassName #>, <#= ItemTypeName #>>();
        public bool IsInvalid => !IsValid;
        public Span<<#= ItemTypeName #>> GetRowSpan(int row) => this.GetRowSpan<<#= ClassName #>, <#= ItemTypeName #>>(row);
        public ReadOnlySpan<<#= ItemTypeName #>> GetRoRowSpan(int row) => this.GetRowSpan<<#= ClassName #>, <#= ItemTypeName #>>(row);

        // IEquatable<T>
        public bool Equals(<#= ClassName #> other) => this == other;
        public override bool Equals(object? obj) => (obj is <#= ClassName #> other) && Equals(other);
        public override int GetHashCode() => HashCode.Combine(_pointer, _rows, _columns, _bytesPerItem, _stride);

        public static bool operator ==(in <#= ClassName #> left, in <#= ClassName #> right)
             => (left._pointer, left._rows, left._columns, left._bytesPerItem, left._stride)
                == (right._pointer, right._rows, right._columns, right._bytesPerItem, right._stride);

        public static bool operator !=(in <#= ClassName #> left, in <#= ClassName #> right) => !(left == right);

    }
}
